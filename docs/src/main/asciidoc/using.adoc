[[using]]
= Using Datasource Micrometer

include::_attributes.adoc[]

This section goes into more detail about how you should use {project-full-name}.

[[using-types-of-observation]]
== Types of Observations

The {project-full-name} creates Connection, Query, Generated Keys(from `v1.1`), and ResultSet observations.

The Connection observation represents the database connection operations. It is the base observation, as any database access requires a connection.
The Query observation provides query execution details, such as execution time, SQL query, bind parameters, etc.
The Generated Keys observation records generated keys when auto-generated keys feature is used for the insert statements.
The ResultSet observation shows how the operations fetched the data from the query result, including the number of retrieved rows.

To configure these observations, see <<howto.adoc#how-to-add-tracingobservationhandler>>.  +
For Spring Boot, see <<howto.adoc#how-to-choose-what-to-observe>>.


[[using-features]]
== Features

[[using-features-hikaricp-support]]
=== HikariCP Support

`jdbc.datasource.driver` and `jdbc.datasource.pool` tags are available when the target datasource is a `HikariDataSource`.

The `HikariJdbcObservationFilter` provides this feature and this observation filter needs to be registered to the `ObservationRegistry`.

[source,java,indent=0]
----
ObservationRegistry registry = ...
registry.observationConfig().observationFilter(new HikariJdbcObservationFilter());
----

It is auto configured in `datasource-micrometer-spring-boot`.

[[using-features-remote-ip-and-port]]
=== Remote IP and Port

For spans, remote IP and port are retrieved from the datasource url.

[[using-features-remote-service-name]]
=== Remote Service Name

The datasource name is used as the remote service name in spans.
The name is specified when creating a proxy datasource by {datasource-proxy}[datasource-proxy].

[source,java,indent=0]
----
DataSource instrumented =
    ProxyDataSourceBuilder.create(dataSource)
        .name("myDS")    // Specify datasource name
        .listener(listener)
        .methodListener(listener)
        .build;
----

For `datasource-micrometer-spring-boot`, the datasource name is resolved by looking the catalog name at start up (or the connection pool name for Hikari, then fallback to its beanname) by default.

To specify a custom datasource name, see <<howto.adoc#how-to-customize-the-proxydatasource-name>> and <<howto.adoc#how-to-customize-the-proxydatasource-creation>> section.

[[using-features-application-events]]
=== Application Events
Since version `1.1`, `datasource-micrometer-spring-boot` can publish Spring's application events for query executions and method invocations on proxied JDBC classes.
This feature is disabled by default and can be enabled by setting the property `jdbc.event.enabled=true`.
When enabled, it publishes events - `JdbcQueryExecutionEvent` and `JdbcMethodExecutionEvenet`.

[[using-limitations]]
== Limitations
[[using-limitations-open-session-in-view]]
=== Open Session In View

NOTE: The following limitation applies only to versions prior to `v1.2`.
Starting with `v1.2`, the duration of the connection observation scope has been shortened, and OIV is handled correctly.
For more details, see issue https://github.com/jdbc-observations/datasource-micrometer/issues/82[gh-82].


When working with Open-In-View (Open Session In View (OSIV) or Open EntityManager In View (OEIV)), special care is required.
This is because OIV delays closing the database connection, which can affect the boundaries of observations.

For example, consider the following code:

[source,java]
----
@GetMapping("/")
List<Car> cars() {
  return Observation.createNotStarted("my.observation", registry).observe(() -> {
    return repository.findAll();  // DB access
  });
}
----

With OIV *disabled*, the observation interaction looks like this:

----
Action                | Name
----------------------|--------------------
START Observation     | "http.server.requests"
OPEN Scope            | "http.server.requests"
START Observation     | "my.observation"
OPEN Scope            | "my.observation"
START Observation     | "jdbc.connection"
OPEN Scope            | "jdbc.connection"
...                   | ...
CLOSE Scope           | "jdbc.connection"
STOP Observation      | "jdbc.connection"
CLOSE Scope           | "my.observation"
STOP Observation      | "my.observation"
CLOSE Scope           | "http.server.requests"
STOP Observation      | "http.server.requests"
----

With OIV *enabled*, the order changes:

----
Action                | Name
----------------------|--------------------
START Observation     | "http.server.requests"
OPEN Scope            | "http.server.requests"
START Observation     | "my.observation"
OPEN Scope            | "my.observation"
START Observation     | "jdbc.connection"
OPEN Scope            | "jdbc.connection"
...                   | ...
CLOSE Scope           | "my.observation"      <==
STOP Observation      | "my.observation"      <==
CLOSE Scope           | "jdbc.connection"     <==
STOP Observation      | "jdbc.connection"     <==
CLOSE Scope           | "http.server.requests"
STOP Observation      | "http.server.requests"
----

As you can see, when OIV is enabled, the `jdbc.connection` observation/scope is closed *after* the `my.observation` observation/scope.
Since scopes must be closed in the reverse order of their opening, this swapped order can cause leaks in thread-local bound values (such as spans), because opening and closing scopes trigger thread-local operations.

The example above uses an explicitly created observation, but the same applies if you use the `@Observed` annotation or another instrumentation library.
Therefore, when OIV is enabled, pay careful attention to observation boundaries â€” especially if the observation includes database access.

In upcoming versions, we plan to narrow the scope of connection observations to better support the OIV pattern.

[[using-limitations-open-session-in-view-post-v1.2-behavior]]
==== Post-v1.2 Behavior
Starting with `v1.2`, the scope of the connection observation has been shortened, so OIV now works correctly. +
The observation order looks like this:

----
Action                | Name
----------------------|--------------------
START Observation     | "http.server.requests"
OPEN Scope            | "http.server.requests"
START Observation     | "my.observation"
OPEN Scope            | "my.observation"
START Observation     | "jdbc.connection"
OPEN Scope            | "jdbc.connection"
CLOSE Scope           | "jdbc.connection"  <== Immediately after acquiring a connection
...                   | ...
CLOSE Scope           | "my.observation"
STOP Observation      | "my.observation"
STOP Observation      | "jdbc.connection"  <==
CLOSE Scope           | "http.server.requests"
STOP Observation      | "http.server.requests"
----

